   Вирус заражает файлы(ELF: EXEC, DYNAMIC, x86-64) только в текущей директории, не изменяя их размера, подменяя адрес вызова функции.
   Запускает новый процесс с полезной нагрузкой - SURPRISE, который работает как дочерний.
   Передаёт управление оригинальному коду.
*меняет размеры сегментов и секций
*может заразить файл не польностью, но это не должно повлиять на правильность его(файла) работы 
*шифрует(изменяет) весь код кроме START_LOADER 
;---------------------------------------------------------------------------------------------------------------------------------------------------------
   Файл hello изменён по адресам(смещения в файле):
     0x0e   - 0xAA (метка, по которой понятно, что файл заражён)
     0x114c - подмена адреса функции (команда 'call offs'(0xbytebytebytebyteE8), заменена на 0x0000002FE8)
     0x618 - SURPRISE(полезная нагрузка, код, который будет запущен в отдельном процессе),
     0x20ec - MAIN_LOADER(главная часть shell кода, которая заражает файлы, запускает SURPRISE)
     0x1180 - START_LOADER(самая маленькая часть shell кода, которя прячется в EXECUT сегменте, обеспечивая загрузку, передачу управления, MAIN_LOADER)
SURPISE      - размер==0x10 bytes; расположен в секции: LOAD, NOEXECUT;  
MAIN LOADER  - размер==0xcb0(3248) bytes; расположен в секции: LOAD, NOEXECUT(НЕ В ТОЙ ЖЕ САМОЙ ЧТО И SURPRISE);
START LOADER - размер==0x4c(76) bytes; расположен в секции: LOAD, EXECUT;
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Код вируса вызывается первой командой('CALL':0x..E8 или'CALLN':0x..15ff или'CALLF':0x..16ff) оригинального кода, запускается START_LOADER...
   START_LOADER : выделяет память, расшифровывает MAIN_LOADER и запускает его
   MAIN_LOADER  : 1. ищет файл, если его нет, то прыгает на пункт 3;
                  2. заражает(или пытается) файл и прыгает на пункт 1; 
                  3. создаёт дочерний процесс с кодом SURPRIZE
                  4. прыгает на оригинальный код (на адрес, который должна была вызвать подмененная функция) - ложит адрес на стек + ret
   ORIGINAL CODE: ...
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                       START_LOADER:
1. Копирует из стека адрес возврата в rax;
2. Сохраняет некоторые регистры(rdi, rsi, rdx, rcx)
3. Выделяет 8kb памяти для расшифровки и запуска MAIN LOADER, вызывая два раза syscall-'brk()'(первый раз - узнаёт начальный адрес для выделения памяти;
      второй раз - 'выделяет память' двигает начальный адрес на 8kb
4. Наделяет выделенную память размером 8kb правами доступа на: чтение, запись, исполнение 
5. Копирует из стека адрес возврата в rsi(как в пункт 1.) и кладёт его на вершину стека для дальнейшего копирования его в r13 в MAIN_LOADER
   !!! Адрес возврата из функции START LOADER нужен для вычесления виртульных адресов кода, отображённого в памяти загрузчиком Linux
   !!! Адрес возврата из функции START LOADER + смещение в файле == нужный адрес кода в виртуальной памяти процесса
   !!! смещение вычисляется при заражении файла как: адрес возврата - адрес нужного кода(r13 - adr code) 
6. Копирует и расшифровывает код MAIN LOADER из LOAD READ сегмента в выделенную память код 
7. Передаёт управление на выделенную память с правами на исполнение(MAIN LOAD) командой 'jmp rdi'
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                       MAIN_LOADER:
IN:  rdi - адрес выделенной памяти размером 8kb с кодом MAIN LOADER; edx - ключ для расшифровки MAIN LOADER и SURPISE в ТЕКУЩЕМ файле;
      [rsp-8] - адрес возврата из START LOADER 
 
1. Сохраняет остальные регистры в стеке; копирует: [rsp-8] в r13, rdi в rbp, edx в r12d;
   !!! r13, rbp, r12 - играют ключeвую роль в заражении(функция'_infect') и в MAIN_LOADER не изменяются
2. Открывает текущую директорию(функция'_dir_open', имя:'.')
3. Читает директорию(функция'_dir_read'), если директория пуста, то выполняет пункт 5.
4. Начинает анализировать файлы в текущей директории вызывая функцию'read_files':
   4.1 Проверяет исполняемый файл или директория, если нет, то выполняет пункт 4.1
   4.2 Если файл - это директория, то выполняется inf_dir(ничего не делает),
       Если файл - это исполняемый файл, то выполняется inf_file,
       Если файл - это что-то другое, то возврщается к началу'read_files'(пункт 4.1) 
      ('inf_file'):
      4.2.1 Проверяем права доступа заражаемого файла(может ли владелец выполнять его) и узнаём его размер после вызова функции'_file_stat'
            Если файл не исполняемый, то выполняет пункт 4
      4.2.2 Выполняется заражение файла функцией'_infect'   --- !!!подробное описание смотреть дальше!!!
      4.2.3 Прыгает на 'nxt_file', где либо выполняет пункт 4.1, либо завершает 'read_files'
   4.3 Выполняет пункт 3.
5. Запускает код полезной нагрузки(SURPRIZE)(функция'_start_payload')
   5.1   Создаёт новый процесс syscall'fork()'
   5.2   В новом процессе, после завершения выполнения кода SURPRISE, выполняется syscall'exit'
6. Достаёт из стека все сохранённые регистры(ВСЕ кроме rax)
7. Кладёт на вершину стека адрес(r13+OFFS_OF_ORIG_CODE) кода, который должен был выполняться вместо START_LOADER, и передаёт на него выполнение командой'ret'
;-----------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                      _infect:
1. Открывает заражаемый файл(функция'_file_open')
2. Отображает файл в памяти(функция'_mmap')
3. Анализирует заголовки файла(функция'check_exec), проверяя его на корректность и сохраняя некоторые значения в регистры, если файл некорректен, то выполняет пункт 10.:
   rdi - адрес начала файла в памяти; si - e_pnum; dx - e_shnum; r10 - e_phoff; r11 - e_shoff;
4. Анализирует сегменты файла и заполняет битовую карту сегментов в r9(фукция'check_seg'). Номер бита - номер сегмента, если бит установлен, значит сегмент LOAD.
      Вмещает только 32 сегмента! С 0-31 биты - READ/READandWRITE сегменты. C 32-63 биты - EXECUT сегменты.
5. Проверяет заражён ли файл или нет(функция'check_infected'), если заражён([rdi+14]==0xAA), то выполняет пункт 10.
6. Копирует SURPRISE в заражаемый файл из текущего файла:
   6.1   Берёт код по адресу r13+OFFS_SURPRISE и копирует его, расшифровывая(функция'xor_code') ключом(r12), в память, выделенную в START LOAD(адрес в rbp)+0x1000
   6.2   Меняет ключ на новый(mov r12, rbp). !!! Весь код шифруется адресом, который хранится в rbp(память, выделннная в START_LOADER)!!!
   6.3   Копирует код SURPRISE в заражаемый файл(функция'infect_shell_data), если не удалось, то выполняет пункт 10. 
      !!!Адрес в памяти, с которого начинается SURPRISE в заражаемом файле, хранится в r14!!!
   6.4  Шифрует SURPRISE в заражаемом файле новым ключом('xor_code') 
   6.5  Изменяет размеры сегмента и секций(секции) в заголовках заражаемого файла
7. Копирует MAIN_LOADER в заражаемый файл из текущего:
   7.1 Копирует код MAIN_LOADER из памяти, выделенной в START_LOADER(отсюда он сейчас и исполняется), в заражаемый файл(функция'infect_shell_data')
       Если не удалось, то пункт 10. !!!Адрес в памяти, с которого начинается MAIN_LOADER в заражаемом файле, хранится в r15!!!
   7.2  Изменяет размеры сегмента и секций(секции) в заголовках заражаемого файла
   7.3  (Подмена функции - 'find_entr')Ищет в оригинальном коде(ORIGINAL CODE) 'CALL'или'CALLN'или'CALLF', адрес которого можно заменить на START_LOADER
        Возвращает в rbx адрес(!в памяти) следующей команды после 'CALL...', если не находит, то выполняет пункт 10.
         !!! адрес в rbx - это ТОТ САМЫЙ адрес, который будет в r13, когда заражаемый файл будет ЗАПУЩЕН!!!
   7.4  Вычисляет смещение в заражаемом файле, от следующей команды после подмененной функции(пункт 7.3) до SURPRISE - (sub r14, rbx\n mov r14, rbx)
   7.5  Изменяет код MAIN_LOADER в заражаемом файле:
      7.5.1 Меняет адрес OFFS_SURPRISE(cur_add: mov rsi, r13\n mov rcx, OFFS_SURPRISE), который используется в пункте 6.1, когда заражаемый файл будет исполняться 
      7.5.2 Меняет адрес ADDR_OF_SURPRISE_CODE(curr_add_stpay: mov eax, ADDR_OF_SURPRISE_CODE), который используется в пункте MAIN_LOADER: 5., когда заражаемый файл будет исполняться
      7.5.3 Меняет адрес OFFS_OF_ORIG_CODE(ml_exit: mov ebx, OFFS_OF_ORIG_CODE), который используется в пункте MAIN_LOADER: 7., когда заражаемый файл будет исполняться 
      7.5.4 Меняет 4 байта кода в MAIN_LOADER(ml_exit: ...\n add rax, rbx\n 0xXXXXXXXX):
             Если в пункте 7.3 был обнаружен опкод'CALL'(0xE8) - меняет на "cmp rax, 0" 
             Если в пункте 7.3 был обнаружен опкод'CALLF'/'CALLN'(0xFF, mod==3/2) - меняет на "mov rax, [rax]" 
8.Копирует START_LOADER в заражаемый файл из текущего:
   8.1 Копирует(собирает/очищает от 'jmp')код(функция'collect_shell_exec')START_LOADER из текущего файла в буфер(rbp+0x1000 как ранее)
   8.2 Копирует код(функция'infect_shell_exec'там изменяются размеры сегментов/секций)START_LOADER из буфера(адрес которого возвращает функция'collect_shell_exec), в заражаемый файл
      Если не удалось, то пункт 10. !!!Адрес в памяти, с которого начинается START_LOADER в заражаемом файле, хранится в rbx!!!
   8.3  Вычисляет смещение в заражаемом файле, от следующей команды после подмененной функции(пункт 7.3) до START_LOADER - (xchg r13, r14\n...sub rbx, r13)
   8.4  Меняет адрес OFFS_START_LOAD(cur_add1: mov ebx, OFFS_START_LOAD), который используется в пункте 8.1, когда заражаемый файл будет исполняться 
   8.5  Изменяем в оригинальном коде смещение прыжка 'call'(который был найден в пункте 7.3) на смещение, полученный в (rbx) пункте 8.3
9. Шифруем в заражаемом файле MAIN_LOADER ключом r12
10. Закрываем заражаемый файл(функция'_file_close')
;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                       infect_shell_exec:
1. Достаёт из r9(31-63bits) номер сегмента, который LOAD EXECUT
2. Вычисляет адрес начала нужного заголовка в памяти
3. Ищет свободные места(минимум 8bytes) в сегменте и записывает туда код, изменяя размеры сегмента и секций(функция'nork_in_segment'):
   3.1 Находит адрес и размер секции, которая располагается в нужном сегменте
   3.2 Ищет свободное место и записывает туда код(или его часть)(функция'find_nork'). 
         'find_nork' использует таблицу 'tab_code_len' в которой индекс - номер команды START_LOADER, а значение байта по индексу - размер команды START_LOAd в байтах
         'tab_code_len' расположена в коде функции'nork_in_segment'
   3.3 Изменяет размер сегмента и секции, если в предыдущем пункте код был записан в секцию заражаемого файла
   3.4 Если код закончился или закончились секции в данном сегменте, то выходит из 'nork_in_segment'(Переходит к пункту 4.), иначе выполняет пункт 3.1 
4. Если код, который нужно нужно внедрить закончился или кончились LOAD EXECUT секции, то выходит из функции
   Если нет, то выполняет пункт 2
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                          find_nork:
1. Ищет в секции пустые(0x00) 8bytes("norks") и более. Если закончилась секция или код, то выходит из функции.
   !!!Формат "norks" == командакоманда... + дальний/ближний jmp + ret !!!
2. Если это первый вызов, то выполняет пункт 3., иначе:
   2.1 Проверяет расстояние от последней записанной ранее командой кода START_LOADER в заражённый файл до участка памяти в который сейчас будут записаны новые команды.
   2.2 Если расстояние в пределах -125 до 125, то меняет в предыдущей "norks" дальний jmp на ближний jmp и дописывает команды('write_shell'), если они влазят в "norks" 
   2.3 Записывает адрес прыжка в предыдущем "norks" на текущюю "norks"
3. Записывает в текущую "norks" код START_LOADER + дальний jmp + ret(функция'write_shell') 
4. Если закончился код, то выходит из 'find_nork', иначе выполняет пункт 1.
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                          write_shell:
1. Проверяет сколько команд влезет в "norks", учитывая что дальний jmp занимает 5 байт, ближний 2+ret. (Дальний jmp может быть заменён на ближний только в пункте find_nork:2.2)
2. Копирует побайтно код START_LOADER из "пункт _infect:8.1" в заражаемый файл
   + ищет по сигнатурам места в START_LOADER, где копируется ключ и OFFS_ML(mov edx, 0xkey и mov eax, OFFS_ML). Вставляет в эти места кода нужные данные:
   ключ - rbp; offs - sub r15, r13
3. Выбирает какой jmp дописать в конец "norks"
4. Выходит из функции
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
